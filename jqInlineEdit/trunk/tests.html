<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>jqInlineEdit jQuery Plugin - Live Demo &amp; Documentation</title>
		<link rel="stylesheet" type="text/css" media="all" href="tests.css" />
		<script type="text/javascript" src="3rd-party/jquery-1.4.4.min.js"></script>
		<script type="text/javascript" src="3rd-party/tiny_mce.js"></script>
		<script type="text/javascript" src="jquery.jqInlineEdit.js"></script>
		<script type="text/javascript" src="tests.js"></script>
    </head>
    <body>
        <h1>jqInlineEdit jQuery Plugin - Live Demo &amp; Documentation</h1>
		
		<!-- We need a form for many reasons and test purposes -->
		<form action="target.html">

		<h2>0 - Introduction</h2>
		
		...TODO...
		
		<h2>1 - Let's Start Simple</h2>
		
		<div id="example1-1" class="example">
			<h3>Example 1.1: The Most Basic Example In The World</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit it.
			</div>
			<pre>
    >>> $("#example1-1 .exampleBody strong").inlineEdit();
			</pre>	
			<p class="summary">
				Simple: you can customize the bold text clicking on it.<br/>
				Click <code>ENTER</code> key to accept the new value, or <code>ESC</code>
				key to cancel editing and restoring original value.<br/>
				Remember that when the field loose focus, is like when you click <code>ENTER</code>:
				the new value is accepted.
			</p>
		</div>

		<div id="example1-2" class="example">
			<h3>Example 1.2: More To Be Edited</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> or on the <em>italic</em> ones.<br/>
			</div>
			<pre>
    >>> $("#example1-2 .exampleBody strong,#example1-2 .exampleBody em").inlineEdit();
			</pre>
			<p class="summary">
				When editing a field you can click onto another field to stop editing the first and
				starting editing the second.<br/>
				By default you can edit only one field at time.
			</p>
		</div>

		<h2>2 - Somewhere Above Defaults</h2>

		<div id="example2-1" class="example">
			<h3>Example 2.1: Multiple Editing</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> again, but also the <em>italic</em> ones.
			</div>
			<pre>
    >>> $("#example2-1 .exampleBody strong,#example2-1 .exampleBody em")
    ...     .inlineEdit({multiEditing: true});
			</pre>
			<p class="summary">
				You can start editing more than a field, not forced to one.<br/>
				For this, you simple need to use the <code class="api">multiEditing</code> option to
				<code>true</code>.<br/>
				In this case if the field loose focus it will no accept the new value nor discard it;
				you need to go back to the field and press <code>ENTER</code>.
			</p>
		</div>

		<div id="example2-2" class="example">
			<h3>Example 2.2: Force User To Accept Changes</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit. Click away to cancel what you've edited.
			</div>
			<pre>
    >>> $("#example2-2 .exampleBody strong")
    ...     .inlineEdit({acceptOnBlur: false});
			</pre>
			<p class="summary">
				If you don't like that clicking away is intended like a &quot;take this new text&quot; action,
				you can put the <code class="api">acceptOnBlur</code> option to <code>false</code>.<br/>
				Changing this will make the loose of focus like the pressure of the <code>ESC</code> key. 
			</p>
		</div>

		<div id="example2-3" class="example">
			<h3>Example 2.3: Change &quot;Abort&quot; Key</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit. <code>ESC</code> key will not cancel the action
				anymore; instead use <code>BACKSPACE</code>.<br/>
				Customize also the <em>italic</em> text, but no cancel key will works.
			</div>
			<pre>
    >>>	$("#example2-3 .exampleBody strong")
    ...     .inlineEdit({cancelKey: 8});
    >>> $("#example2-3 .exampleBody em")
    ...     .inlineEdit({cancelKey: null});
			</pre>
			<p class="summary">
				Use the <code class="api">cancelKey</code> options to change the key that abort editing from
				<code>ESC</code> (code 27, the default) to what you want.<br/>
				If you put it to <code>null</code> value, no key will work anymore for this action
				(maybe the loose of focus will continue working, if you  not played with
				<code class="api">acceptOnBlur</code>
				value).
			</p>
		</div>

		<div id="example2-4" class="example preventMovingOn">
			<h3>Example 2.4: Change &quot;Accept&quot; Key</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit. The <code>ENTER</code> key will not accept
				changes anymore (<strong>note</strong> that if you use it you will see a Javascript popup,
				but in a normal situation, when pressing this key inside a HTML <code>FORM</code> element,
				you will leave the current page), instead use <code>KEY-DOWN</code>.<br/>
				Customize also the <em>italic</em> text, but to accept changes you need to click away from
				the field, making it loosing focus.
			</div>
			<pre>
    >>>	$("#example2-4 .exampleBody strong")
    ...     .inlineEdit({acceptKey: 40});
    >>> $("#example2-4 .exampleBody em")
    ...     .inlineEdit({acceptKey: null});
			</pre>
			<p class="summary">
				Use the <code class="api">acceptKey</code> options to change the key that confirm changes from
				<code>ENTER</code> (code 13, the default) to what you want.<br/>
				If you put it to <code>null</code> value, no key will work anymore for this action
				(maybe the loose of focus will continue working, based on your
				<code class="api">acceptOnBlur</code> value).<br/>
				<strong>N.B.:</strong> if you use <code>ENTER</code> key, while the alert message is displayed,
				you'll see the new text like if changes has been accepted, but remember that is not the key you
				pressed that accepted the new value: when you submit a form (like you did pressing
				<code>ENTER</code>) the current selected field is also loosing focus! So: is the
				<em>blur</em> action that make magic.
			</p>
		</div>

		<div id="example2-4-1" class="example subExample preventMovingOn">
			<h4>Example 2.4.1: Change &quot;Accept&quot; Key (With Different Blur Handling)</h4>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit. <code>ENTER</code> key will not accept changes
				anymore (and in the popup you'll see the old value).
			</div>
			<pre>
    >>>	$("#example2-4-1 .exampleBody strong")
    ...     .inlineEdit({acceptKey: 40,
    ...                  acceptOnBlur: false});
			</pre>
			<p class="summary">
				Continuing example above: this time the <em>blur</em> action will not change the value so
				you leave the page with old values.
			</p>
		</div>

		<div id="example2-4-2" class="example subExample">
			<h4>Example 2.4.2: Change &quot;Accept&quot; Key (This Time Preventing <code>ENTER</code>
			Key From Changing Page)</h4>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit. <code>ENTER</code> key will not accept changes
				anymore (again, use <code>KEY-DOWN</code>).
			</div>
			<pre>
    >>>	$("#example2-4-2 .exampleBody strong")
    ...     .inlineEdit({acceptKey: 40,
    ...                  preventFormSubmission: true});
			</pre>
			<p class="summary">
				This set of examples shows you that inside <code>FORM</code> the <code>ENTER</code> key is
				special and commonly will submit it.<br/>
				Right now I prevent you from moving on another page, but commonly how can you stop
				<code>ENTER</code> doing this if you don't like it but still you don't want that
				<code>ENTER</code> accept new values?<br/>
				Simple: you need to use also the <code class="api">preventFormSubmission</code> parameter,
				a specific option for this need. 
			</p>
		</div>

		<h2>3 - Let's Start Beeing Useful: Events</h2>

		<div id="example3-1" class="example">
			<h3>Example 3.1: Before Anything Else</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> or the <em>italic text</em> for edit.
				But you will not be able to edit the bold ones.<br/>
				However... have you noted that those texts are bigger than normal?
			</div>
			<pre>
    >>> $("#example3-1 .exampleBody strong,#example3-1 .exampleBody em")
    ...     .inlineEdit({onInit: function() {
    ...         this.css('font-size', '130%');
    ...         return this.is('em');
    ...     }});
			</pre>
			<p class="summary">
				You can use the <code class="api">onInit</code> parameter for giving to the plugin something
				to do... &quot;before all&quot;.<br/>
				The function you passed is called on every element of the jQuery set. Inside this function the
				<code>this</code> object is referred to the current jQuery context.<br/>
				You can use this function only for doing something on those elements (like make the font
				bigger?), but if <code class="api">onInit</code> will return a boolean
				<code>false</code>, the jqInlineEdit mechanism will be stopped for this element. This means that
				it will not be aditable.<br/>
			</p>
		</div>

		<div id="example3-2" class="example">
			<h3>Example 3.2: Before Editing</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> or the <em>italic text</em> for edit.
				You will be warned by a message every time you try to edit, but only the bold text will
				be editable after the message.
			</div>
			<pre>
    >>> $("#example3-2 .exampleBody strong,#example3-2 .exampleBody em")
    ...     .inlineEdit({beforeEdit: function() {
    ...         alert('you are trying to edit this text: ' + this.text());
    ...         return this.is('strong');
    ...     }});
			</pre>
			<p class="summary">
				Go back to the previous example for a while. It shows you how to &quot;make something&quot;
				after you started the inline edit procedure. When you rely onto
				<code class="api">onInit</code> you must know that it is called once; returning
				<code>false</code> from it will stop one or more elements of the jQuery set from beeing
				editable.<br/>
				Now I want to show the <code class="api">beforeEdit</code> event, called when the edit procedure
				starts from the user point of view, commonly when the user click on a target element.<br/>
				The bigger difference is that: this event will be called <em>every time</em> the edit
				procedure starts.<br/>
				The <code>this</code> reference inside the event function is the current jQuery context
				(the element you want to edit). Also, returning a boolean <code>false</code>
				from the function will stop the edit procedure, but only this time.
				So, another click on the element will call the function another time (and if this time the
				function doesn't return <code>false</code>, maybe you will be able to edit your text. 
			</p>
		</div>

		<div id="example3-3" class="example">
			<h3>Example 3.3: Before Anything Else (But We Are Talking Of The Editable Field)</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> for edit it.
				Like some example above the font size is a little smaller... but this time also the font size
				inside the text field.
			</div>
			<pre>
    >>> var oversizeMe = function() {
    ...     this.css('font-size', '130%');
	... };
    >>> $("#example3-3 .exampleBody strong").inlineEdit({
    ...         onInit: oversizeMe,
    ...         onInitField: oversizeMe
    ... });
			</pre>
			<p class="summary">
				Another useful API you can use is the <code class="api">onInitField</code> options.
				This is another event someway similar to the <code class="api">onInit</code> I
				explained above.
				The difference is that this new event is called on the text field you use for edit the text,
				so later than <code class="api">onInit</code> execution.<br/>
				When <code class="api">onInit</code> is called, the HTML inside the DOM element doesn't
				contain the field yet.<br/>
				In the example when I introduced <code class="api">onInit</code> event the text editable was
				bigger, but when you start to edit it the text inside the editable field was normal.
				In this example we use the same function for both events.<br/>
				In the <code class="api">onInitField</code> function the <code>this</code> reference is the
				jQuery context wrapping the text field. Again, returning <code>false</code> will abort the
				procedure of update (see next example).
			</p>
		</div>

		<div id="example3-3-1" class="example subExample">
			<h4>Example 3.3.1: Are You Able To Edit The Editable Field?</h4>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> for edit it (sorry... not this time... you'll be
				not able).
			</div>
			<pre>
    >>> $("#example3-3-1 .exampleBody strong").inlineEdit({
    ...     onInit: function() {this.css('font-size', '130%');},
    ...     onInitField: function() {return false;}
    ... });
			</pre>
			<p class="summary">
				Like already said above, returning <code>false</code> from <code class="api">onInitField</code>
				function will not make the field editable. To be more precise: the event function is called
				in the context of the editable field, so after this has been created, but before it is
				attached to the document DOM. So returning <code>false</code> will never make the field
				appear in you page.
			</p>
		</div>

		<div id="example3-4" class="example">
			<h3>Example 3.4: Now Customize The First Event You Have Worked With</h3>
			<div class="exampleBody">
				Move <strong>your</strong> mouse <strong>randomly</strong> on
				<strong>all</strong> bold <strong>text</strong> inside <strong>this</strong> text.
			</div>
			<pre>
    >>> $("#example3-4 .exampleBody strong").inlineEdit({event: 'mouseover'});
			</pre>
			<p class="summary">
				Right now I never talked of the action that starts the inline editing directly,
				showing only one way: the mouse click. Instead also this default activation event can
				be customized. You can use the <code class="api">event</code> parameter to change the
				event that trigger the inline edit from &quot;click&quot; (the default) to
				whatever you want.
			</p>
			<p class="devNote">
				When other fields take focus, seems that the blur event on field tah behave focus is not
				called. Investigate why.
			</p>
		</div>

		<div id="example3-4-1" class="example subExample">
			<h4>Example 3.4.1: ...Also With Custom Events</h4>
			<div class="exampleBody">
				Click on the <em>italic</em> text for customize the <strong>text</strong>.
			</div>
			<pre>
    >>> $("#example3-4-1 .exampleBody em").click(function() {
    ...     $(this).parent().children('strong').trigger('custom')});
    >>> $("#example3-4-1 .exampleBody strong").inlineEdit({event: 'custom'});
			</pre>
			<p class="summary">
				Remember that when you are in the jQuery world is very simple to rely also on
				non-standard Javascript events.<br/>
				The example above shows you that you can use <code class="api">event</code>
				parameter with a non-standard event that you can easilly raise using jQuery
				<a class="jQueryAPI" rel="external" href="http://api.jquery.com/trigger">trigger()</a> method.
			</p>
		</div>

		<div id="example3-5" class="example">
			<h3>Example 3.5: More Interesting: Do Something &quot;After&quot;</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit it and see transformed to upper case.
			</div>
			<pre>
    >>> $("#example3-5 .exampleBody strong").inlineEdit({onEdit: function() {
    ...     this.text(this.text().toUpperCase());
    ... }});
			</pre>
			<p class="summary">
				I don't want to take it longer. Now you are customized you text, but you are able to
				be warned of this update, and make something after.<br/>
				The <code class="api">onEdit</code> function is called when the text has been changes.
				Inside it you can use the <code>this</code> reference to get the edited node.<br/>
				This time what you return from the function doesn't matter. The page has been already
				modified.
			</p>
		</div>

		<div id="example3-6" class="example">
			<h3>Example 3.6: Do Something Also If You Change Idea</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit. Nothing special, but if you abort the editing
				with <code>ESC</code> key, you'll see an alert with the discarded text.
			</div>
			<pre>
    >>> $("#example3-6 .exampleBody strong").inlineEdit({onCancel: function(discardedText) {
    ...     alert('The node text is still "'+this.text()+'" while the discarded text is "'+discardedText+'".');
    ... }});
			</pre>
			<p class="summary">
				Similar to the <code class="api">onEdit</code> event, you can pass the
				<code class="api">onCancel</code> parameter, to invoke a custom function that will be called
				when the user want to discard changes. Use <code>this</code> for a reference to the node you
				were editing.<br/>
				Again: like the <code class="api">onEdit</code>, the returning value is ignored, but this time
				the function can have a parameter: <code class="apiParameter">discardedText</code>. This is the
				text that the user entered but that will be lost because he cancel the action.<br>/
			</p>
		</div>

		<h2> Stopping Inline Edit </h2>
		
		<div id="example4-1" class="example">
			<h3>Example 4.1: Editable No More</h3>
			<div class="exampleBody">
				Click on all <strong>bold text</strong> that <strong>you see there</strong>.
				After that ther first bold text will not be editable anymore.
			</div>
			<pre>
    >>> var boldSet = $("#example4-1 .exampleBody strong");
    >>> boldSet.inlineEdit({onEdit: function() {
    ...    $(boldSet.get(0)).stopInlineEdit();
    ... }});
			</pre>
			<p class="summary">
				In every moment you want, you can choose to stop elemens from being editable.
				You only need to construct a jQuery set (not required that this set in the same you used
				for beginning the inline edit procedure... maybe you want to use only a subset?)
				and call on it the <code class="api">stopInlineEdit</code> method.<br/>
				After this call all stuff that made elements in the set editable, are removed (data,
				events and so on). If you change idea... let's start from scratch!
			</p>
		</div>

		<h2> Validation </h2>

		<div id="example5-1" class="example">
			<h3>Example 5.1: Validation (In General)</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit it. You <em>must</em> modify the text copying
				exactly (case sensitive) the text you find in the italic text that follow:
				<em>The Cat is on the Table</em>.
			</div>
			<pre>
    >>> $("#example5-1 .exampleBody strong").inlineEdit({validate: function(newValue) {
    ...     var italicText = this.nextAll('em:eq(1)').text();
    ...     if (newValue!==italicText) {
    ...         return false;
    ...     }
    ... }});
			</pre>
			<p class="summary">
				The <code class="api">validate</code> parameter is really important. It can be used to validate your
				input automatically after submission.<br/>
				In its general version, <code class="api">validate</code> is a function called before the user changes
				are applied.<br/>
				Inside the function, the <code>this</code> reference if the current jQuery content.
				The function can have a <code class="apiParameter">newValue</code> parameter that is the new value
				that the user want to submit to validation.<br/>
				If the function return a boolean <code>false</code>, the plugin cancel the action.<br/>
			</p>
		</div>

		<div id="example5-2" class="example">
			<h3>Example 5.2: RegExp Validation Shortcut</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit it. You <em>must</em> change the text with
				a number, or you changes will be discarded.
			</div>
			<pre>
    >>> $("#example5-2 .exampleBody strong").inlineEdit(
    ...     {validate: /(^-?\d\d*\.\d*$)|(^-?\d\d*$)|(^-?\.\d\d*$)/}
    ... );
			</pre>
			<p class="summary">
				This example want to show you a shortcut. One of the most useful way to perform validation
				based only on the text value is the use of
				<a rel="external" class="jsAPI"
				href="http://www.w3schools.com/jsref/jsref_obj_regexp.asp">RegExp Javascript object</a>.<br/>
				If you use as <code class="api">validate</code> parameter a <code>RegExp</code> object,
				it will be automatically tested with the new value typed by the user.
				If the results is <code>false</code> then no changes will be applied.<br/>
				Please note that this version of the use of <code class="api">validate</code> is a shortcut.
				You can reach the same behaviour using <code class="api">validate</code> as a function that
				test the new value inside it with a <code>RegExp</code>.
			</p>
		</div>

		<h2> A Bit Of Style </h2>

		<div id="example6-1" class="example">
			<h3>Example 6.1: Style For All Editable Element</h3>
			<div class="exampleBody">
				No example for this... or better: <em>every</em> test you seen in this page
				is an example for this. Have you noted that all editable elements, when the mouse
				move on them, are changing the cursor to a pointer?
			</div>
    		<pre>
    .inlineEditableElement {
        cursor: pointer;
    }
			</pre>
			<p class="summary">
				When you enable the inline edit, automatically you are applying a new CSS class
				named &quot;<em>inlineEditableElement</em>&quot; to them.<br/>
				This is the default value for the <code class="api">editableClass</code>
				parameter.<br/>
				The only code I can put here is the CSS rules used in this documentation page.
			</p>
		</div>

		<div id="example6-2" class="example">
			<h3>Example 6.2: More Styles For All Editable Element</h3>
			<div class="exampleBody">
				Click on the <strong>first bold text</strong> if you like. The <strong>second one</strong>
				instead is not editable. Note the special style applied to the editable text... and thanks
				to this style you are able to see that <span>there is another editable text</span> (I said:
				not the second bold text!).
			</div>
			<pre>
    >>> $("#example6-2 .exampleBody strong:first,#example6-2 .exampleBody span").inlineEdit({
    ...     editableClass: 'ImEditable'
    ... });
			</pre>
			<p class="summary">
				Editable elements in a set can be very heterogeneous and for sure you must think about
				the user accessibility. You need to mark in some special way the editable areas.
				The <code class="api">editableClass</code> parameter is a class name(s) to be applied to
				all editable elements in the set.<br/>
				Note that in this example we are applying only the &quot;<em>ImEditable</em>&quot;, not the
				 &quot;<em>inlineEditableElement</em>&quot;. Continue reading for more info about this.
			</p>
		</div>
		
		<div id="example6-2-1" class="example subExample">
			<h4>Example 6.2.1: More (And More) Styles For All Editable Element</h4>
			<div class="exampleBody">
				The <strong>bold text</strong> there is editable (aren't you tired of this?)
				but is more important note how many new class are added to the element.
			</div>
			<pre>
    >>> $("#example6-2-1 .exampleBody strong").inlineEdit({
    ...     editableClass: 'inlineEditableElement ImEditable ImReallyEditable fooClass'
    ... });
			</pre>
			<p class="summary">
				You can give multiple class to the <code class="api">editableClass</code> parameter,
				putting a space for divide them.<br/>
				When you use this parameter for changing the default, think about put also in the list
				the plugin default &quot;<em>inlineEditableElement</em>&quot;. However this is not required.
			</p>
		</div>

		<div id="example6-3" class="example">
			<h3>Example 6.3: Style Is Not For All</h3>
			<div class="exampleBody">
				There are originally <strong>three</strong> editable text
				<strong>inside this document</strong>.<br/>
				You can edit <strong>all but the second</strong>. So you style is applied to all but this
				elements.
			</div>
			<pre>
    >>> $("#example6-3 .exampleBody strong").inlineEdit({
    ...     onInit: function() {
    ...         if (this.text()==='inside this document') {
    ...             return false;
    ...         }
    ...     },
    ...     editableClass: 'inlineEditableElement ImEditable'
    ... });
			</pre>
			<p class="summary">
				The <code class="api">editableClass</code> provided is applied to element in the page that
				are really editable.<br/>
				This mean that if you also use the <code class="api">onInit</code> parameter with an init
				function to be called, if this function return <code>false</code> in the context of an
				element, the item is not editable.
				An for this reason also the CSS class is not given to the element.
			</p>
		</div>

		<h2> More Text </h2>

		<div id="example7-1" class="example">
			<h3>Example 7.1: Are You Able To Handle All This Text?</h3>
			<div class="exampleBody">
				The is a big paragraph inside this example. Click and edit it
				<p class="text">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque vitae tortor quam. Morbi
ut dui nibh. Etiam mattis vehicula urna in imperdiet. Phasellus faucibus condimentum augue
venenatis blandit. Donec fermentum ligula eget mi eleifend a lobortis diam eleifend.
In dictum consectetur leo, vel ullamcorper metus auctor ut. Proin non lorem eu dolor
lobortis venenatis vulputate sit amet arcu. Nullam imperdiet blandit lacus; eu fringilla
nunc congue non. Fusce id venenatis ipsum? Nam sed arcu et velit fermentum euismod.
Integer consequat interdum arcu vitae laoreet. Praesent vitae ipsum a dolor viverra
pulvinar nec et odio. Curabitur vel massa at erat suscipit volutpat quis vitae dui.
Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.</p>
			</div>
			<pre>
    >>> $("#example7-1 .exampleBody p.text").inlineEdit({
    ...     multiLine: true
    ... });
			</pre>
			<p class="summary">
				When the text size to edit begin to grow, a better way to edit code content is using a
				<code>textarea</code> instead of a text <code>input</code>.<br/>
				The <code class="api">multiLine</code> parameter is responsible of this; its default
				value <code>false</code> says that the HTML element used will be a text input field.
				Change it to <code>true</code> to use an HTML <code>textarea</code>.<br/>
				<strong>Note</strong> that when putting <code class="api">multiLine</code> paramenter
				to <code>true</code>, the <code>ENTER</code> key will not be used anymore as accept key.
				Inside <code>textarea</code> this key is for normal newline usage.
			</p>
		</div>

		<div id="example7-2" class="example">
			<h3>Example 7.2: Not Simple Text</h3>
			<div class="exampleBody">
				Click on the editable pararaph and edit it, but note that inside you'll see also HTML tags.
				Try to play with HTML tags (if you are not an expert of HTML, try to put a random
				&quot;&lt;hr/&gt;&quot; inside the text; this will add an horizontal line inside text).
<div class="text">
<p>
Lorem ipsum dolor sit amet, consectetur adipiscing elit. <em>Quisque ut diam sit amet justo volutpat convallis.
Vestibulum convallis consectetur risus; eget gravida odio sollicitudin non! Aliquam aliquam, sem at convallis
posuere, nunc arcu imperdiet diam, non</em>luctus tellus massa eget erat! Suspendisse felis massa, elementum sit
amet eleifend sed, tincidunt vel purus. Maecenas faucibus nunc sit amet turpis rutrum rutrum. Pellentesque
ornare mi nec turpis sagittis nec rutrum sapien tempor! Integer pellentesque sollicitudin feugiat. Quisque
malesuada, mauris ac lacinia consequat, nisi velit commodo metus, sed molestie massa turpis vitae sem. Aenean
vitae lorem lectus, vel placerat erat. Morbi interdum orci ut massa scelerisque faucibus. Morbi id orci nunc.
Ut at nisl sed metus tempor egestas et non dui. Suspendisse pretium libero mauris. Nam erat velit; blandit et
sagittis ut; ultricies eu est. Sed massa mauris, consequat id ultrices in, eleifend sit amet arcu. Suspendisse
facilisis egestas massa et egestas. Praesent eget ligula orci, nec venenatis dolor? Morbi ultricies, est vel
consectetur venenatis, tellus urna sollicitudin leo, vel eleifend sapien nulla id augue. Maecenas rhoncus
tincidunt mattis.
</p>

<p>
Suspendisse lacus dui, tempus quis rutrum in, venenatis non purus? Donec sit amet magna vitae erat sodales
porttitor. Praesent in sapien sed arcu varius pulvinar non a mi. Duis adipiscing suscipit placerat. Aenean feugiat
consequat nunc, quis rutrum <strong>nulla dignissim a</strong>. Vestibulum pharetra, leo a rutrum blandit, nulla mauris
elementum eros, sed commodo mi ante vel nibh. Cras feugiat nisl sit amet mauris scelerisque id placerat elit placerat!
Vivamus at euismod sapien. Maecenas justo libero, luctus ut ultrices a, blandit sed velit. Proin consequat lacus
et nunc aliquet et fringilla enim congue. Morbi laoreet est commodo ipsum dapibus a eleifend justo sollicitudin!
Integer ac porta nisl. Nulla scelerisque consequat arcu eget consectetur. Aenean id elementum tortor. Aliquam
turpis nunc, auctor id imperdiet et, fermentum a elit! In iaculis porttitor fringilla.
</p>
</div>
			</div>
			<pre>
    >>> $("#example7-2 .exampleBody .text").inlineEdit({
    ...     multiLine: true,
    ...     contentType: 'html'
    ... });
			</pre>
			<p class="summary">
				I didn't talk about it, but in the last example you can see that edit multiline text block
				in an HTML environment is not so interesting.
				All whitespaces and newline are really saved and are still there if you go back to edit the
				text, but they leave to no effect to the page.<br/>
				When you want to edit a piece of page that isn't a simple string text, like in all other
				examples we see there, you will get more effect beeing able to manage the HTML itself, not
				simple text.<br/>
				This example show you the use of <code class="api">contentType</code> parameter, that is
				defaulted to <code>text</code>. If you change it to <code>HTML</code> you say to the plugin
				that you want to edit the text node as HTML, not simple text. 
			</p>
		</div>

		<div id="example7-2-1" class="example subExample">
			<h4>Example 7.2.1: HTML In Simple Text Lines</h4>
			<div class="exampleBody">
				Click on <strong>the<sup>bold text</sup></strong> and see you can use HTML there.
			</div>
			<pre>
    >>> $("#example7-2-1 .exampleBody strong").inlineEdit({
    ...     contentType: 'html'
    ... });
			</pre>
			<p class="summary">
				Not so common, but you can use <code class="api">contentType</code> as <code>html</code>
				also for non-multiline text.
			</p>
		</div>

		<div id="example7-3" class="example">
			<h3>Example 7.3: Edit HTML Manually Is For Loosers</h3>
			<div class="exampleBody">
				Click again on the big editable paragraph... and watch the surprise.
<div class="text">
<p>
Lorem ipsum dolor sit amet, consectetur adipiscing elit. <em>Quisque ut diam sit amet justo volutpat convallis.
Vestibulum convallis consectetur risus; eget gravida odio sollicitudin non! Aliquam aliquam, sem at convallis
posuere, nunc arcu imperdiet diam, non</em>luctus tellus massa eget erat! Suspendisse felis massa, elementum sit
amet eleifend sed, tincidunt vel purus. Maecenas faucibus nunc sit amet turpis rutrum rutrum. Pellentesque
ornare mi nec turpis sagittis nec rutrum sapien tempor! Integer pellentesque sollicitudin feugiat. Quisque
malesuada, mauris ac lacinia consequat, nisi velit commodo metus, sed molestie massa turpis vitae sem. Aenean
vitae lorem lectus, vel placerat erat. Morbi interdum orci ut massa scelerisque faucibus. Morbi id orci nunc.
Ut at nisl sed metus tempor egestas et non dui. Suspendisse pretium libero mauris. Nam erat velit; blandit et
sagittis ut; ultricies eu est. Sed massa mauris, consequat id ultrices in, eleifend sit amet arcu. Suspendisse
facilisis egestas massa et egestas. Praesent eget ligula orci, nec venenatis dolor? Morbi ultricies, est vel
consectetur venenatis, tellus urna sollicitudin leo, vel eleifend sapien nulla id augue. Maecenas rhoncus
tincidunt mattis.
</p>

<p>
Suspendisse lacus dui, tempus quis rutrum in, venenatis non purus? Donec sit amet magna vitae erat sodales
porttitor. Praesent in sapien sed arcu varius pulvinar non a mi. Duis adipiscing suscipit placerat. Aenean feugiat
consequat nunc, quis rutrum <strong>nulla dignissim a</strong>. Vestibulum pharetra, leo a rutrum blandit, nulla mauris
elementum eros, sed commodo mi ante vel nibh. Cras feugiat nisl sit amet mauris scelerisque id placerat elit placerat!
Vivamus at euismod sapien. Maecenas justo libero, luctus ut ultrices a, blandit sed velit. Proin consequat lacus
et nunc aliquet et fringilla enim congue. Morbi laoreet est commodo ipsum dapibus a eleifend justo sollicitudin!
Integer ac porta nisl. Nulla scelerisque consequat arcu eget consectetur. Aenean id elementum tortor. Aliquam
turpis nunc, auctor id imperdiet et, fermentum a elit! In iaculis porttitor fringilla.
</p>
</div>
				Want to stop editing? <a href="" class="stopTiny">click here</a>!<br/>
				When Tiny is removed we'll see the <code>textarea</code> field! To restore our modified
				text, go the field, giving it the focus, then press <code>ESC</code>
				(as we configured this key as accept key).<br/>
				How ugly!
			</div>
			<pre>
    >>> $("#example7-3 .exampleBody .text").inlineEdit({
    ...     multiLine: true,
    ...     contentType: 'html',
    ...     multiEditing: true,
    ...     cancelKey: null,
    ...     acceptKey: 27,
    ...     afterInitField: function() {
    ...         this.attr('id', 'foo1');
    ...         tinyMCE.execCommand('mceAddControl', false, "foo1");
    ...     }
    ... });
    >>> $("#example7-3 .exampleBody .stopTiny").click(function(event){
    ...     event.preventDefault();
    ...     tinyMCE.execCommand('mceRemoveControl', false, "foo1");
    ... });
			</pre>
			<p class="summary">
				For this interesting example I call a friend: the
				<a href="http://tinymce.moxiecode.com/" rel="external">TinyMCE WYSIWYG editor</a>.<br/>
				Edit HTML is a great feature, but not so useful if you need to do it manually. This example
				is shows you the great power of the plugin when you don't need only to edit simple text.<br/>
				In this example we use the new <code class="api">afterInitField</code> parameter, a callable
				function that we can use to perform something just after the editable field has been inited.
				In this function you can refer to <code>this</code> as the jQuery context referred to the 
				text field.<br/>
				Note that we need to use also the <code class="api">multiLine</code> parameter, as when TinyMCE
				start, our field loose the focus but we still need to have as as a <code>textarea</code>
				even if hidden by TinyMCE.
			</p>
		</div>

		<div id="example7-3-1" class="example subExample">
			<h4>Example 7.3.1: Again Use TinyMCE (But A Better Example)</h4>
			<div class="exampleBody">
				Click on the <a href="">EDIT</a> link and play with TinyMCE; click again for stop editing.
<div class="text">
<p>
Lorem ipsum dolor sit amet, consectetur adipiscing elit. <em>Quisque ut diam sit amet justo volutpat convallis.
Vestibulum convallis consectetur risus; eget gravida odio sollicitudin non! Aliquam aliquam, sem at convallis
posuere, nunc arcu imperdiet diam, non</em>luctus tellus massa eget erat! Suspendisse felis massa, elementum sit
amet eleifend sed, tincidunt vel purus. Maecenas faucibus nunc sit amet turpis rutrum rutrum. Pellentesque
ornare mi nec turpis sagittis nec rutrum sapien tempor! Integer pellentesque sollicitudin feugiat. Quisque
malesuada, mauris ac lacinia consequat, nisi velit commodo metus, sed molestie massa turpis vitae sem. Aenean
vitae lorem lectus, vel placerat erat. Morbi interdum orci ut massa scelerisque faucibus. Morbi id orci nunc.
Ut at nisl sed metus tempor egestas et non dui. Suspendisse pretium libero mauris. Nam erat velit; blandit et
sagittis ut; ultricies eu est. Sed massa mauris, consequat id ultrices in, eleifend sit amet arcu. Suspendisse
facilisis egestas massa et egestas. Praesent eget ligula orci, nec venenatis dolor? Morbi ultricies, est vel
consectetur venenatis, tellus urna sollicitudin leo, vel eleifend sapien nulla id augue. Maecenas rhoncus
tincidunt mattis.
</p>

<p>
Suspendisse lacus dui, tempus quis rutrum in, venenatis non purus? Donec sit amet magna vitae erat sodales
porttitor. Praesent in sapien sed arcu varius pulvinar non a mi. Duis adipiscing suscipit placerat. Aenean feugiat
consequat nunc, quis rutrum <strong>nulla dignissim a</strong>. Vestibulum pharetra, leo a rutrum blandit, nulla mauris
elementum eros, sed commodo mi ante vel nibh. Cras feugiat nisl sit amet mauris scelerisque id placerat elit placerat!
Vivamus at euismod sapien. Maecenas justo libero, luctus ut ultrices a, blandit sed velit. Proin consequat lacus
et nunc aliquet et fringilla enim congue. Morbi laoreet est commodo ipsum dapibus a eleifend justo sollicitudin!
Integer ac porta nisl. Nulla scelerisque consequat arcu eget consectetur. Aenean id elementum tortor. Aliquam
turpis nunc, auctor id imperdiet et, fermentum a elit! In iaculis porttitor fringilla.
</p>
</div>

			</div>
			<pre>

			</pre>
			<p class="summary">
				
			</p>
		</div>


		</form>
		
    </body>
</html>
