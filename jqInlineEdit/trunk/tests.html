<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>jqInlineEdit jQuery Plugin - Live Demo &amp; Documentation</title>
		<link rel="stylesheet" type="text/css" media="all" href="tests.css" />
		<script type="text/javascript" src="jquery-1.4.4.min.js"></script>
		<script type="text/javascript" src="jquery.jqInlineEdit.js"></script>
		<script type="text/javascript" src="tests.js"></script>
    </head>
    <body>
        <h1>jqInlineEdit jQuery Plugin - Live Demo &amp; Documentation</h1>
		
		<!-- We need a form for many reasons and test purposes -->
		<form action="target.html">

		<h2>0 - Introduction</h2>
		
		...TODO...
		
		<h2>1 - Let's Start Simple</h2>
		
		<div id="example1-1" class="example">
			<h3>Example 1.1: The Most Basic Example In The World</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit it.
			</div>
			<pre>
    >>> $("#example1-1 .exampleBody strong").inlineEdit();
			</pre>	
			<p class="summary">
				Simple: you can customize the bold text clicking on it.<br/>
				Click <code>ENTER</code> key to accept the new value, or <code>ESC</code>
				key to cancel editing and restoring original value.<br/>
				Remember that when the field loose focus, is like when you click <code>ENTER</code>:
				the new value is accepted.
			</p>
		</div>

		<div id="example1-2" class="example">
			<h3>Example 1.2: More To Be Edited</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> or on the <em>italic</em> ones.<br/>
			</div>
			<pre>
    >>> $("#example1-2 .exampleBody strong,#example1-2 .exampleBody em").inlineEdit();
			</pre>
			<p class="summary">
				When editing a field you can click onto another field to stop editing the first and
				starting editing the second.<br/>
				By default you can edit only one field at time.
			</p>
		</div>

		<h2>2 - Somewhere Above Defaults</h2>

		<div id="example2-1" class="example">
			<h3>Example 2.1: Multiple Editing</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> again, but also the <em>italic</em> ones.
			</div>
			<pre>
    >>> $("#example2-1 .exampleBody strong,#example2-1 .exampleBody em")
    ...     .inlineEdit({multiEditing: true});
			</pre>
			<p class="summary">
				You can start editing more than a field, not forced to one.<br/>
				For this, you simple need to use the <code class="api">multiEditing</code> option to
				<code>true</code>.<br/>
				In this case if the field loose focus it will no accept the new value nor it discard it;
				you need to go back to the field and press <code>ENTER</code>.
			</p>
		</div>

		<div id="example2-2" class="example">
			<h3>Example 2.2: Force User To Accept Changes</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit. Click away to cancel what you've edited.
			</div>
			<pre>
    >>> $("#example2-2 .exampleBody strong")
    ...     .inlineEdit({acceptOnBlur: false});
			</pre>
			<p class="summary">
				If you don't like that clicking away is intended like a &quot;take this new text&quot; action,
				you can put the <code class="api">acceptOnBlur</code> option to <code>false</code>.<br/>
				Changing this will make the loose of focus like the pressure of the <code>ESC</code> key. 
			</p>
		</div>

		<div id="example2-3" class="example">
			<h3>Example 2.3: Change &quot;Abort&quot; Key</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit. <code>ESC</code> key will not cancel the action
				anymore; instead use <code>BACKSPACE</code>.<br/>
				Customize also the <em>italic</em> text, but no cancel key will works.
			</div>
			<pre>
    >>>	$("#example2-3 .exampleBody strong")
    ...     .inlineEdit({cancelKey: 8});
    >>> $("#example2-3 .exampleBody em")
    ...     .inlineEdit({cancelKey: null});
			</pre>
			<p class="summary">
				Use the <code class="api">cancelKey</code> options to change the key that abort editing from
				<code>ESC</code> (code 27, the default) to what you want.<br/>
				If you put it to <code>null</code> value, no key will work anymore for this action
				(maybe the loose of focus will continue working, if you  not played with
				<code class="api">acceptOnBlur</code>
				value).
			</p>
		</div>

		<div id="example2-4" class="example preventMovingOn">
			<h3>Example 2.4: Change &quot;Accept&quot; Key</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit. The <code>ENTER</code> key will not accept
				changes anymore (<strong>note</strong> that if you use it you will see a Javascript popup,
				but in a normal situation, when pressing this key inside a HTML <code>FORM</code> element,
				you will leave the current page), instead use <code>KEY-DOWN</code>.<br/>
				Customize also the <em>italic</em> text, but to accept changes you need to click away from
				the field, making it loosing focus.
			</div>
			<pre>
    >>>	$("#example2-4 .exampleBody strong")
    ...     .inlineEdit({acceptKey: 40});
    >>> $("#example2-4 .exampleBody em")
    ...     .inlineEdit({acceptKey: null});
			</pre>
			<p class="summary">
				Use the <code class="api">acceptKey</code> options to change the key that confirm changes from
				<code>ENTER</code> (code 13, the default) to what you want.<br/>
				If you put it to <code>null</code> value, no key will work anymore for this action
				(maybe the loose of focus will continue working, based on your
				<code class="api">acceptOnBlur</code> value).<br/>
				<strong>N.B.:</strong> if you use <code>ENTER</code> key, while the alert message is displayed,
				you'll see the new text like if changes has been accepted, but remember that is not the key you
				pressed that accepted the new value: when you submit a form (like you did pressing
				<code>ENTER</code>) the current selected field is also loosing focus! So: is the
				<em>blur</em> action that make magic.
			</p>
		</div>

		<div id="example2-4-1" class="example subExample preventMovingOn">
			<h4>Example 2.4.1: Change &quot;Accept&quot; Key (With Different Blur Handling)</h4>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit. <code>ENTER</code> key will not accept changes
				anymore (and in the popup you'll see the old value).
			</div>
			<pre>
    >>>	$("#example2-4-1 .exampleBody strong")
    ...     .inlineEdit({acceptKey: 40,
    ...                  acceptOnBlur: false});
			</pre>
			<p class="summary">
				Continuing example above: this time the <em>blur</em> action will not change the value so
				you leave the page with old values.
			</p>
		</div>

		<div id="example2-4-2" class="example subExample">
			<h4>Example 2.4.2: Change &quot;Accept&quot; Key (This Time Preventing <code>ENTER</code>
			Key From Changing Page)</h4>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit. <code>ENTER</code> key will not accept changes
				anymore (again, use <code>KEY-DOWN</code>).
			</div>
			<pre>
    >>>	$("#example2-4-2 .exampleBody strong")
    ...     .inlineEdit({acceptKey: 40,
    ...                  preventFormSubmission: true});
			</pre>
			<p class="summary">
				This set of examples shows you that inside <code>FORM</code> the <code>ENTER</code> key is
				special and commonly will submit it.<br/>
				Right now I prevent you from moving on another page, but commonly how can you stop
				<code>ENTER</code> doing this if you don't like it but still you don't want that
				<code>ENTER</code> accept new values?<br/>
				Simple: you need to use also the <code class="api">preventFormSubmission</code> parameter,
				a specific option for this need. 
			</p>
		</div>

		<h2>3 - Let's Start Beeing Useful: Events</h2>

		<div id="example3-1" class="example">
			<h3>Example 3.1: Before Anything Else</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> or the <em>italic text</em> for edit.
				But you will not be able to edit the bold ones.<br/>
				However... have you noted that those texts are bigger than normal?
			</div>
			<pre>
    >>> $("#example3-1 .exampleBody strong,#example3-1 .exampleBody em")
    ...     .inlineEdit({onInit: function() {
    ...         this.css('font-size', '130%');
    ...         return this.is('em');
    ...     }});
			</pre>
			<p class="summary">
				You can use the <code class="api">onInit</code> parameter for giving to the plugin something
				to do... &quot;before all&quot;.<br/>
				The function you passed is called on every element of the jQuery set. Inside this function the
				<code>this</code> object is referred to the current jQuery context.<br/>
				You can use this function only for doing something on those elements (like make the font
				bigger?), but if <code class="api">onInit</code> will return a boolean
				<code>false</code>, the jqInlineEdit mechanism will be stopped for this element. This means that
				it will not be aditable.<br/>
			</p>
		</div>

		<div id="example3-2" class="example">
			<h3>Example 3.2: Before Editing</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> or the <em>italic text</em> for edit.
				You will be warned by a message every time you try to edit, but only the bold text will
				be editable after the message.
			</div>
			<pre>
    >>> $("#example3-2 .exampleBody strong,#example3-2 .exampleBody em")
    ...     .inlineEdit({beforeEdit: function() {
    ...         alert('you are trying to edit this text: ' + this.text());
    ...         return this.is('strong');
    ...     }});
			</pre>
			<p class="summary">
				Go back to the previous example for a while. It shows you how to &quot;make something&quot;
				after you started the inline edit procedure. When you rely onto
				<code class="api">onInit</code> you must know that it is called once; returning
				<code>false</code> from it will stop one or more elements of the jQuery set from beeing
				editable.<br/>
				Now I want to show the <code class="api">beforeEdit</code> event, called when the edit procedure
				starts from the user point of view, commonly when the user click on a target element.<br/>
				The bigger difference is that: this event will be called <em>every time</em> the edit
				procedure starts.<br/>
				The <code>this</code> reference inside the event function is the current jQuery context
				(the element you want to edit). Also, returning a boolean <code>false</code>
				from the function will stop the edit procedure, but only this time.
				So, another click on the element will call the function another time (and if this time the
				function doesn't return <code>false</code>, maybe you will be able to edit your text. 
			</p>
		</div>

		<div id="example3-3" class="example">
			<h3>Example 3.3: Before Anything Else (But We Are Talking Of The Editable Field)</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> for edit it.
				Like some example above the font size is a little smaller... but this time also the font size
				inside the text field.
			</div>
			<pre>
    >>> var oversizeMe = function() {
    ...     this.css('font-size', '130%');
	... };
    >>> $("#example3-3 .exampleBody strong").inlineEdit({
    ...         onInit: oversizeMe,
    ...         onInitField: oversizeMe
    ... });
			</pre>
			<p class="summary">
				Another useful API you can use is the <code class="api">onInitField</code> options.
				This is another event someway similar to the <code class="api">onInit</code> I
				explained above.
				The difference is that this new event is called on the text field you use for edit the text,
				so later than <code class="api">onInit</code> execution.<br/>
				When <code class="api">onInit</code> is called, the HTML inside the DOM element doesn't
				contain the field yet.<br/>
				In the example when I introduced <code class="api">onInit</code> event the text editable was
				bigger, but when you start to edit it the text inside the editable field was normal.
				In this example we use the same function for both events.<br/>
				In the <code class="api">onInitField</code> function the <code>this</code> reference is the
				jQuery context wrapping the text field. Again, returning <code>false</code> will abort the
				procedure of update (see next example).
			</p>
		</div>

		<div id="example3-3-1" class="example subExample">
			<h4>Example 3.3.1: Are You Able To Edit The Editable Field?</h4>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> for edit it (sorry... not this time... you'll be
				not able).
			</div>
			<pre>
    >>> $("#example3-3-1 .exampleBody strong").inlineEdit({
    ...     onInit: function() {this.css('font-size', '130%');},
    ...     onInitField: function() {return false;}
    ... });
			</pre>
			<p class="summary">
				Like already said above, returning <code>false</code> from <code class="api">onInitField</code>
				function will not make the field editable. To be more precise: the event function is called
				in the context of the editable field, so after this has been created, but before it is
				attached to the document DOM. So returning <code>false</code> will never make the field
				appear in you page.
			</p>
		</div>

		<div id="example3-4" class="example">
			<h3>Example 3.4: Now Customize The First Event You Have Worked With</h3>
			<div class="exampleBody">
				Move <strong>your</strong> mouse <strong>randomly</strong> on
				<strong>all</strong> bold <strong>text</strong> inside <strong>this</strong> text.
			</div>
			<pre>
    >>> $("#example3-4 .exampleBody strong").inlineEdit({event: 'mouseover'});
			</pre>
			<p class="summary">
				Right now I never talked of the action that starts the inline editing directly,
				showing only one way: the mouse click. Instead also this default activation event can
				be customized. You can use the <code class="api">event</code> parameter to change the
				event that trigger the inline edit from &quot;click&quot; (the default) to
				whatever you want.
			</p>
			<p class="devNote">
				When other fields take focus, seems that the blur event on field tah behave focus is not
				called. Investigate why.
			</p>
		</div>

		<div id="example3-4-1" class="example subExample">
			<h4>Example 3.4.1: ...Also With Custom Events</h4>
			<div class="exampleBody">
				Click on the <em>italic</em> text for customize the <strong>text</strong>.
			</div>
			<pre>
    >>> $("#example3-4-1 .exampleBody em").click(function() {
    ...     $(this).parent().children('strong').trigger('custom')});
    >>> $("#example3-4-1 .exampleBody strong").inlineEdit({event: 'custom'});
			</pre>
			<p class="summary">
				Remember that when you are in the jQuery world is very simple to rely also on
				non-standard Javascript events.<br/>
				The example above shows you that you can use <code class="api">event</code>
				parameter with a non-standard event that you can easilly raise using jQuery
				<a class="jQueryAPI" rel="external" href="http://api.jquery.com/trigger">trigger()</a> method.
			</p>
		</div>

		<div id="example3-5" class="example">
			<h3>Example 3.5: More Interesting: Do Something &quot;After&quot;</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit it and see transformed to upper case.
			</div>
			<pre>
    >>> $("#example3-5 .exampleBody strong").inlineEdit({onEdit: function() {
    ...     this.text(this.text().toUpperCase());
    ... }});
			</pre>
			<p class="summary">
				I don't want to take it longer. Now you are customized you text, but you are able to
				be warned of thi update, and make something after.<br/>
				The <code class="api">onEdit</code> function is called when the text has been changes.
				Inside it you can use the <code>this</code> reference to get the edited node.<br/>
				This time what you return from the function doesn't matter. The page has been already
				modified.
			</p>
		</div>

		<div id="example3-6" class="example">
			<h3>Example 3.6: Do Something Also If You Change Idea</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit. Nothing special, but if you abort the editing
				with <code>ESC</code> key, you'll see an alert with the discarded text.
			</div>
			<pre>
    >>> $("#example3-6 .exampleBody strong").inlineEdit({onCancel: function(discardedText) {
    ...     alert('The node text is still "'+this.text()+'" while the discarded text is "'+discardedText+'".');
    ... }});
			</pre>
			<p class="summary">
				Similar to the <code class="api">onEdit</code> event, you can pass the
				<code class="api">onCancel</code> parameter, to invoke a custom function that will be called
				when the user want to discard changes. Use <code>this</code> for a reference to the node you
				were editing.<br/>
				Again: like the <code class="api">onEdit</code>, the returning value is ignored, but this time
				the function can have a parameter: <code class="apiParameter">discardedText</code>. This is the
				text that the user entered but that will be lost because he cancel the action.<br>/
			</p>
		</div>

		<h2> Stopping Inline Edit </h2>
		
		<div id="example4-1" class="example">
			<h3>Example 4.1: Editable No More</h3>
			<div class="exampleBody">
				Click on all <strong>bold text</strong> that <strong>you see there</strong>.
				After that ther first bold text will not be editable anymore.
			</div>
			<pre>
    >>> var boldSet = $("#example4-1 .exampleBody strong");
    >>> boldSet.inlineEdit({onEdit: function() {
    ...    $(boldSet.get(0)).stopInlineEdit();
    ... }});
			</pre>
			<p class="summary">
				In every moment you want, you can choose to stop elemens from being editable.
				You only need to construct a jQuery set (not required that this set in the same you used
				for beginning the inline edit procedure... maybe you want to use only a subset?)
				and call on it the <code class="api">stopInlineEdit</code> method.<br/>
				After this call all stuff that made elements in the set editable, are removed (data,
				events and so on). If you change idea... let's start from scratch!
			</p>
		</div>

		<h2> Validation </h2>

		<div id="example5-1" class="example">
			<h3>Example 5.1: Validation (In General)</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit it. You <em>must</em> modify the text copying
				exactly (case sensitive) the text you find in the italic text that follow:
				<em>The Cat is on the Table</em>.
			</div>
			<pre>
    >>> $("#example5-1 .exampleBody strong").inlineEdit({validate: function(newValue) {
    ...     var italicText = this.nextAll('em:eq(1)').text();
    ...     if (newValue!==italicText) {
    ...         return false;
    ...     }
    ... }});
			</pre>
			<p class="summary">
				The <code class="api">validate</code> parameter is really important. It can be used to validate your
				input automatically after submission.<br/>
				In its general version, <code class="api">validate</code> is a function called before the user changes
				are applied.<br/>
				Inside the function, the <code>this</code> reference if the current jQuery content.
				The function can have a <code class="apiParameter">newValue</code> parameter that is the new value that
				the user want to submit to validation.<br/>
				If the function return a boolean <code>false</code>, the plugin cancel the action.<br/>
			</p>
		</div>

		<div id="example5-2" class="example">
			<h3>Example 5.2: RegExp Validation Shortcut</h3>
			<div class="exampleBody">
				Click on the <strong>bold text</strong> to edit it. You <em>must</em> change the text with
				a number, or you changes will be discarded.
			</div>
			<pre>
    >>> $("#example5-2 .exampleBody strong").inlineEdit(
    ...     {validate: /(^-?\d\d*\.\d*$)|(^-?\d\d*$)|(^-?\.\d\d*$)/}
    ... );
			</pre>
			<p class="summary">
				This example want to show you a shortcut. One of the most useful way to perform validation
				based only on the text value is the use of
				<a rel="external" class="jsAPI"
				href="http://www.w3schools.com/jsref/jsref_obj_regexp.asp">RegExp Javascript object</a>.<br/>
				If you use as <code class="api">validate</code> parameter a <code>RegExp</code> object,
				it will be automatically tested with the new value typed by the user.
				If the results is <code>false</code> then no changes will be applied.<br/>
				Please note that this version of the use of <code class="api">validate</code> is a shortcut.
				You can reach the same behaviour using <code class="api">validate</code> as a function that
				test the new value inside it with a <code>RegExp</code>.
			</p>
		</div>

		<h2> A Bit Of Style </h2>

		<div id="example6-1" class="example">
			<h3>Example 6.1: Styles For All Editable Element</h3>
			<div class="exampleBody">
				Click on the <strong>first bold text</strong> if you like. The <strong>second one</strong>
				instead is not editable. Note the special style applied to the editable text... and thank
				to this style you are able to see that <span>there is another editable text</span> (I said:
				not the second bold text!).
			</div>
			<pre>
    >>> $("#example6-1 .exampleBody strong:first,#example6-1 .exampleBody span").inlineEdit({
    ...     editableClass: 'ImEditable'
    ... });
			</pre>
			<p class="summary">
				Editable elements in a set can be very heterogeneous and for sure you must think about
				the user accessibility. You need to mark in some special way the editable areas.
				The <code class="api">editableClass</code> parameter is a class name(s) to be applied to
				all editable elements in the set.
			</p>
		</div>
		
		<div id="example6-1-1" class="example">
			<h4>Example 6.1.1: More Styles For All Editable Element</h3>
			<div class="exampleBody">
				The <strong>bold text</strong> there is editable, with two classes applied.
			</div>
			<pre>
    >>> $("#example6-1-1 .exampleBody strong").inlineEdit({
    ...     editableClass: 'ImEditable ImReallyEditable fooClass'
    ... });
			</pre>
			<p class="summary">
				You can give multiple class to the <code class="api">editableClass</code> parameter,
				putting a space for divide them.
			</p>
		</div>


		</form>
		
    </body>
</html>
